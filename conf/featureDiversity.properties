# recommendation algorithm
#rec.recommender.class=net.librec.recommender.baseline.MostPopularRecommender
rec.recommender.class=net.librec.recommender.cf.ItemKNNRecommender

dfs.data.dir=./myData
data.input.path=rating/rating_1kU_20100_binary.csv
#dfs.membership.dir=membership/membership.csv

dfs.log.dir=./log
dfs.result.dir=../result
data.log.out.path=./result/results.txt


# appender class
feature.appender.class=net.librec.data.convertor.appender.ItemFeatureAppender

# path to item feature file
data.itemfeature.path=itemfeature/myfeatures.csv
# path to user feature file
# data.userfeature.path=userfeature/userfeature.csv

# select feature for appender
data.feature=female


data.column.format=UIR
data.model.splitter=ratio
data.splitter.trainset.ratio=0.8
data.splitter.ratio=rating


rec.random.seed=201905


rec.recommender.isranking=true
rec.recommender.ranking.topn=10



# todo: adding itemfeature, userfeature. options: user, item, item-feature, user-feature
rec.recommender.similarities=itemfeature,item

# todo: adding a couple of metrics so we know which similarity metrics uses what class
# it's like it's only taking the first one into account!
rec.similarity.class=cos,pcc
rec.similarity.shrinkage=10


rec.eval.enable=true
#rec.eval.classes=net.librec.eval.ranking.DiversityByFeaturesEvaluator,net.librec.eval.ranking.DiversityEvaluator
rec.eval.classes=ils,diversity

# if we have both item,itemfeature and only rec.similarity.class=cos we assume cosine for all of them.
# todo: what about its other variations? if we have rec.recommender.similarities=itemfeature,item and rec.similarity.class=cos, will it calcualte both similarities based on cos? YEEEE
# todo: if we have rec.recommender.similarities=itemfeature,item  and rec.similarity.class=cos,cos and one rec.eval.classes=net.librec.eval.ranking.DiversityEvaluator, will it calcualte it twice?
# todo: should I change the evaluate function in AbstractRecommenderEvaluator to set the similarityMatrix to the right one? (by rating or by feature)
# todo: none of the evaluation metrics use similarity matrix, except diversity evaluator and the ones that we want to implement.
# todo: which similairy matrix algorithms such as knn will use? Isn't it better just to create a featureSimilaityMatrix separately so it doesn't mix up with the similarityMatrix? We don't know which one from similarities will be chosen. how do we train our algorithms?
# todo: in the setup() for these algorithms, the similarity matrix will be retreived. But which one will be retrieved?


rec.neighbors.knn.number=3
rec.neighbors.corate.limit=15


rec.learnrate.bolddriver=false
rec.learnrate.decay=1.0


rec.iterator.learnrate=0.0002
rec.iterator.learnrate.maximum=0.001
rec.iterator.maximum=2

rec.user.regularization=0.00001
rec.item.regularization=0.00001
rec.bias.regularization=0.02

rec.factor.number=3
rec.factor.balance.controller.regularization=0.1

